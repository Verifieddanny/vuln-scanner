import axios from "axios";
import { Vulnerability } from "../types";

export async function scanForVulnerabilities(
  url: string,
  scanTypes: string[]
): Promise<Vulnerability[]> {
  // const vulnerabilities: Vulnerability[] = [];
  const tasks = [];

  const scanFunctions: Record<string, (url: string) => Promise<Vulnerability[]>> = {
    xss: scanForXSS,
    sqli:scanForSQLInjection,
    headers: scanSecurityHeaders,
    ssrf: scanForSSRF,
    csrf: scanForCSRF,
    nosqli: scanForNoSQLInjection,
    rce: scanForRCE,
    lfi: scanForLFI,
    sensitive: scanForSensitiveInfo,
    cors: scanForCORS
  };

  for(const scanType of scanTypes) {
    if(scanFunctions[scanType]) {
      const returnValue = scanFunctions[scanType](url)
      tasks.push(returnValue);
    }
  }

  const results = await Promise.all(tasks);


  return results.flat();
}

  async function scanForXSS(url: string): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];
    const payloads = [
      '<script>alert(1)</script>',
      '"><img src=x onerror=alert(1)>',
      '\'><script>alert(1)</script>',
      'javascript:alert(1)//',
      '"><svg/onload=alert(1)>',
      '`;alert(1);//',
      '\'/><script>-alert(1)-\'',
      '"><iframe/src=javascript:alert(1)>',
      '\\"><img src=x onerror=alert(1)>',
    ];

    for (const payload of payloads) {
      try{
        // Original URL: https://example.com/search
        // After payload injection: https://example.com/search?test=<script>alert(1)</script>

        /**
         * It tests both reflected XSS (via GET requests) and stored XSS (via POST requests). If the server returns the unescaped payload in the response, it indicates a vulnerability.
         */
        const testUrl = `${url}?test=${encodeURIComponent(payload)}`;
        const response = await axios.get(testUrl, {
          validateStatus: () => true
        });

        if(response.data.includes(payload)) {
          vulnerabilities.push({type: 'Cross-Site Scripting (XSS)',
            severity: 'High',
            description: 'Reflected XSS vulnerability detected',
            evidence: `Payload: ${payload}`,
            recommendation: 'Implement proper input validation, output encoding, and Content Security Policy (CSP)',
            cwe: 'CWE-79',
            cvss: 6.1,
            location: 'URL Parameter'})
        };

        const postResponse = await axios.post(url, {
          test: payload
        }, {
          validateStatus: () => true
        });
  
        if (postResponse.data.includes(payload)) {
          vulnerabilities.push({
            type: 'Cross-Site Scripting (XSS)',
            severity: 'High',
            description: 'Stored XSS vulnerability detected',
            evidence: `Payload: ${payload}`,
            recommendation: 'Implement proper input validation, output encoding, and Content Security Policy (CSP)',
            cwe: 'CWE-79',
            cvss: 7.2,
            location: 'POST Parameter'
          });
        }

      } catch (error) {
        console.error('XSS scan error:', error);
      }
    }
  
    return vulnerabilities;
  }


  async function scanSecurityHeaders(url: string): Promise<Vulnerability[]> {
    /**
     * This checks for missing security HTTP headers. For example:
     * 
     * // Making a request to https://example.com
        const response = await axios.get(url);
        const headers = response.headers;

        // Checking if Content-Security-Policy is present
        if (!headers['content-security-policy']) {
          // Site is vulnerable to XSS and other injection attacks
        }
     */
  const vulnerabilities: Vulnerability[] = []
  
  try {
    const response = await axios.get(url)
    const headers = response.headers

    const securityHeaders = {
      /**
       *  Content-Security-Policy (CSP)
          Risk: Cross-Site Scripting (XSS), Data Injection, Clickjacking
          Details:
          Without a CSP header, the browser cannot restrict the sources from which scripts, styles, or other resources can be loaded.
          Attackers can inject malicious scripts into your site, leading to XSS attacks or unauthorized resource loading.
          Clickjacking attacks can also occur as the browser lacks a clear policy to prevent malicious framing.
       */
      'Content-Security-Policy': {
        description: 'Missing Content Security Policy header',
        severity: 'High' as const,
        cwe: 'CWE-1021',
      }
      ,
      /**
       * X-Frame-Options
        Risk: Clickjacking
        Details:
        If this header is missing, your website can be embedded in an iframe on a malicious site.
        Attackers can overlay deceptive elements (like fake buttons) on your site to trick users into clicking them, performing unintended actions (e.g., transferring money or submitting sensitive data).
       */
      'X-Frame-Options': {
        description: 'Missing X-Frame-Options header',
        severity: 'Medium' as const,
        cwe: 'CWE-1021',
      }
      /**
       * Strict-Transport-Security (HSTS)
          Risk: Man-in-the-Middle (MITM) Attacks, Protocol Downgrade Attacks
          Details:
          Without HSTS, users can be tricked into accessing the site over HTTP instead of HTTPS, exposing their data to eavesdropping or manipulation by attackers.
          Attackers can exploit this to inject malicious content or steal sensitive information during transmission.
       */
      ,
      'Strict-Transport-Security': {
        description: 'Missing HSTS header',
        severity: 'Medium' as const,
        cwe: 'CWE-319',
      }
      /**
       *  X-Content-Type-Options
          Risk: Multipurpose Internet Mail Extensions (MIME) Sniffing Attacks
          Details:
          If this header is absent, the browser may attempt to "guess" the content type of a resource, even if it is declared.
          Attackers can exploit this behavior by injecting malicious scripts disguised as other file types (e.g., a script with a .jpg extension).
       */
      ,
      'X-Content-Type-Options': {
        description: 'Missing X-Content-Type-Options header',
        severity: 'Low' as const,
        cwe: 'CWE-16',
      }
      /**
       * Referrer-Policy
        Risk: Information Disclosure
        Details:
        Without this header, the browser may send the full URL of the referring page to the destination site.
        Sensitive data in the URL (e.g., session tokens, user IDs, or query parameters) could be exposed to third-party sites, leading to privacy issues or session hijacking.

       */
      ,
      'Referrer-Policy': {
        description: 'Missing Referrer-Policy header',
        severity: 'Low' as const,
        cwe: 'CWE-200',
      }
      /**
       * Permissions-Policy
          Risk: Abuse of Browser Features
          Details:
          This header controls access to powerful browser features like geolocation, camera, microphone, and more.
          If absent, malicious websites embedded in your application can exploit these features without restriction, leading to privacy violations or unauthorized actions.
       */
      ,
      'Permissions-Policy': {
        description: 'Missing Permissions-Policy header',
        severity: 'Low' as const,
        cwe: 'CWE-693',
      },
    };

    for (const [header, info] of Object.entries(securityHeaders)) {
      if (!headers[header.toLowerCase()]) {
        vulnerabilities.push({
          type: 'Missing Security Header',
          severity: info.severity,
          description: info.description,
          recommendation: `Implement ${header} header`,
          cwe: info.cwe
        })
      }
    }
  } catch (error) {
    console.error('Header scan error:', error)
  }

  return vulnerabilities
}

async function scanForSQLInjection(url: string): Promise<Vulnerability[]> {
  // Tests for SQL injection vulnerabilities by sending malicious SQL fragments:

  /**
   * // Original URL: https://example.com/user
    // After payload: https://example.com/user?id=1' OR '1'='1

    const payload = "1' OR '1'='1";
    const testUrl = `${url}?id=${encodeURIComponent(payload)}`;
   */
  //It looks for SQL error messages in the response that indicate successful injection.
  const vulnerabilities: Vulnerability[] = []
  const payloads = [
    "' OR '1'='1",
    "1' OR '1'='1' --",
    "1; DROP TABLE users--",
    "' OR '1'='1' --",
    "' OR 1=1--",
    "' UNION SELECT NULL--",
    "' UNION SELECT username, password FROM users--",
    "' OR 'a'='a",
    "admin' --",
    "admin' #",
    "' OR '1'='1' /*",
  ];

  for (const payload of payloads) {
    try {
      const testUrl = `${url}?id=${encodeURIComponent(payload)}`
      const response = await axios.get(testUrl)

      
      // Check for SQL error messages
      const errorPatterns = [
        'SQL syntax',
        'mysql_fetch',
        'ORA-',
        'PostgreSQL',
        'SQLite'
      ]

      for (const pattern of errorPatterns) {
        if (response.data.includes(pattern)) {
          vulnerabilities.push({
            type: 'SQL Injection',
            severity: 'Critical',
            description: 'Potential SQL injection vulnerability detected',
            evidence: `Payload: ${payload}, Error: ${pattern}`,
            recommendation: 'Use parameterized queries and input validation',
            cwe: 'CWE-89',
            cvss: 8.5
          })
          break
        }
      }
    } catch (error) {
      console.error('SQL injection scan error:', error)
    }
  }

  return vulnerabilities
}

  async function scanForSSRF(url: string): Promise<Vulnerability[]>{
    //Tests if the server can be tricked into making unauthorized requests:
    const vulnerabilities: Vulnerability[] = [];
    const testUrls = [
      'http://localhost',
      'http://127.0.0.1',
      'http://[::1]',
      'file:///etc/passwd',
      'http://169.254.169.254/latest/meta-data/', // AWS metadata
      'http://metadata.google.internal/', // Google Cloud metadata
      'http://169.254.169.254/metadata/v1/', // DigitalOcean metadata
      'http://192.168.0.1/'
    ];


  for (const testUrl of testUrls) {
    try {
      const params = new URLSearchParams({
        url: testUrl,
        file: testUrl,
        path: testUrl,
        dest: testUrl
      });

      const response = await axios.get(`${url}?${params}`, {
        validateStatus: () => true
      });

      // Check for potential SSRF indicators
      const ssrfIndicators = [
        'passwd:',
        'Private-IP',
        'ami-id',
        'instance-id',
        'internal IP'
      ];

      for (const indicator of ssrfIndicators) {
        if (response.data.includes(indicator)) {
          vulnerabilities.push({
            type: 'Server-Side Request Forgery (SSRF)',
            severity: 'Critical',
            description: 'Potential SSRF vulnerability detected',
            evidence: `Test URL: ${testUrl}, Found indicator: ${indicator}`,
            recommendation: 'Implement URL validation, whitelist allowed hosts, and disable access to internal resources',
            cwe: 'CWE-918',
            cvss: 9.1,
            location: `Parameter containing: ${testUrl}`
          });
          break;
        }
      }
    } catch (error) {
      console.error('SSRF scan error:', error);
    }
  }

  return vulnerabilities;
  }


  async function scanForCSRF(url: string): Promise<Vulnerability[]> {
    // Checks if state-changing operations are protected against CSRF:
    const vulnerabilities: Vulnerability[] = [];
    
    try {
      // Test for state-changing operations
      const testMethods = ['POST', 'PUT', 'DELETE'];
      
      for (const method of testMethods) {
        const response = await axios({
          method,
          url,
          validateStatus: () => true
        });
  
        // Check for missing CSRF tokens
        const headers = response.headers;
        const cookies = headers['set-cookie'] || [];
        const hasCSRFToken = cookies.some(cookie => 
          cookie.toLowerCase().includes('csrf') ||
          cookie.toLowerCase().includes('xsrf')
        );
  
        const body = response.data;
        const hasCSRFField = typeof body === 'string' && (
          body.includes('csrf') ||
          body.includes('_token') ||
          body.includes('xsrf')
        );
  
        if (!hasCSRFToken && !hasCSRFField) {
          vulnerabilities.push({
            type: 'Cross-Site Request Forgery (CSRF)',
            severity: 'High',
            description: `No CSRF protection detected for ${method} request`,
            recommendation: 'Implement CSRF tokens for all state-changing operations',
            cwe: 'CWE-352',
            cvss: 8.0,
            evidence: `Method: ${method}, No CSRF token found in cookies or response body`
          });
        }
      }
    } catch (error) {
      console.error('CSRF scan error:', error);
    }
  
    return vulnerabilities;
  }

  async function scanForRCE(url: string): Promise<Vulnerability[]> {
    //Tests if the server executes injected commands:
    /**
     * // Original URL: https://example.com/execute
        // After payload: https://example.com/execute?cmd=;ls;

        const payload = ';ls;';
        const testUrl = `${url}?cmd=${encodeURIComponent(payload)}`;
        // If response contains directory listing, server is vulnerable to RCE
     */
    const vulnerabilities: Vulnerability[] = [];
    const payloads = [
      ';ls;',
      '|ls|',
      '$(ls)',
      '`ls`',
      '&&ls&&',
      'system(\'ls\')',
      'shell_exec(\'ls\')',
      'eval(\'ls\')',
      '<!--#exec cmd="ls" -->'
    ];
  
    for (const payload of payloads) {
      try {
        const response = await axios.get(`${url}?cmd=${encodeURIComponent(payload)}`, {
          validateStatus: () => true
        });
  
        // Check for command execution indicators
        const rceIndicators = [
          'root:x:0:0',
          'bin/bash',
          'usr/bin',
          'WIN-',
          'WINDOWS\\',
          'Directory of',
          'Volume Serial Number'
        ];
  
        for (const indicator of rceIndicators) {
          if (response.data.includes(indicator)) {
            vulnerabilities.push({
              type: 'Remote Code Execution (RCE)',
              severity: 'Critical',
              description: 'Potential command injection vulnerability detected',
              evidence: `Payload: ${payload}, Found indicator: ${indicator}`,
              recommendation: 'Implement proper input validation and avoid using shell commands with user input',
              cwe: 'CWE-78',
              cvss: 9.8
            });
            break;
          }
        }
      } catch (error) {
        console.error('RCE scan error:', error);
      }
    }
  
    return vulnerabilities;
  }

  
  async function scanForLFI(url: string): Promise<Vulnerability[]> {
    //Checks if server exposes local files (Local File Inclusion):
    /**
     * // Original URL: https://example.com/page
        // After payload: https://example.com/page?file=../../../etc/passwd

        const payload = '../../../etc/passwd';
        const params = new URLSearchParams({ file: payload });
        // If response contains system file content, server is vulnerable to LFI
     */
    const vulnerabilities: Vulnerability[] = [];
    const payloads = [
      '../../../etc/passwd',
      '....//....//....//etc/passwd',
      '..%252f..%252f..%252fetc/passwd',
      '/etc/passwd%00',
      'C:\\Windows\\win.ini',
      'file:///etc/passwd',
      '../../windows/win.ini',
      '%2e%2e%2f%2e%2e%2f%2e%2e%2fetc/passwd'
    ];
  
    const lfiIndicators = [
      'root:x:0:0',
      '[boot loader]',
      'for 16-bit app support',
      'mysql_connect',
      'DOCUMENT_ROOT',
      'HTTP_USER_AGENT'
    ];
  
    for (const payload of payloads) {
      try {
        const params = new URLSearchParams({
          file: payload,
          path: payload,
          include: payload,
          page: payload
        });
  
        const response = await axios.get(`${url}?${params}`, {
          validateStatus: () => true
        });
  
        for (const indicator of lfiIndicators) {
          if (response.data.includes(indicator)) {
            vulnerabilities.push({
              type: 'Local File Inclusion (LFI)',
              severity: 'Critical',
              description: 'Local File Inclusion vulnerability detected',
              evidence: `Payload: ${payload}, Found indicator: ${indicator}`,
              recommendation: 'Implement proper input validation, use whitelisting, and avoid using user input in file operations',
              cwe: 'CWE-98',
              cvss: 7.5
            });
            break;
          }
        }
      } catch (error) {
        console.error('LFI scan error:', error);
      }
    }
  
    return vulnerabilities;
  }

  
  async function scanForNoSQLInjection(url: string): Promise<Vulnerability[]> {
    //Tests for MongoDB-style injection vulnerabilities:
    /**
     * // Testing NoSQL operators
        const payload = '{"$ne": null}';
        const response = await axios.post(url, { query: payload });
        // If query returns results, might be vulnerable to NoSQL injection
     */
    const vulnerabilities: Vulnerability[] = [];
    const payloads = [
      '{"$gt": ""}',
      '{"$ne": null}',
      '{"$where": "sleep(5000)"}',
      '{"$regex": ".*"}',
      '{"$exists": true}',
      '{"$in": []}',
      '{"username": {"$ne": "invalid"}}',
    ];
  
    for (const payload of payloads) {
      try {
        const response = await axios.post(url, {
          query: payload,
          filter: payload,
          search: payload
        }, {
          validateStatus: () => true,
          timeout: 50000
        });
        // Check for NoSQL injection indicators
        if (
          response.status === 200 &&
          (response.data.length > 0 || response.headers['content-length'] > 100)
        ) {
          vulnerabilities.push({
            type: 'NoSQL Injection',
            severity: 'High',
            description: 'Potential NoSQL injection vulnerability detected',
            evidence: `Payload: ${payload}`,
            recommendation: 'Implement proper input validation, use parameterized queries, and avoid using user input directly in queries',
            cwe: 'CWE-943',
            cvss: 7.5
          });
        }
      } catch (error) {
        console.error('NoSQL injection scan error:', error);
      }
    }
  
    return vulnerabilities;
  }

  async function scanForCORS(url: string): Promise<Vulnerability[]> {
    //Checks for misconfigured CORS (Cross-Origin Resource Sharing) policies:
    /**
     * // Testing with malicious origin
        const origin = 'https://evil.com';
        const response = await axios.get(url, {
          headers: { 'Origin': origin }
        });

        // If server allows this origin with credentials, it's vulnerable
        if (response.headers['access-control-allow-origin'] === origin &&
            response.headers['access-control-allow-credentials'] === 'true') {
          // Vulnerable configuration
        }
     */
    const vulnerabilities: Vulnerability[] = [];
    const origins = [
      'https://evil.com',
      'null',
      'https://attacker.com',
      '*',
      'http://localhost:8080'
    ];
  
    for (const origin of origins) {
      try {
        const response = await axios.get(url, {
          headers: {
            'Origin': origin
          },
          validateStatus: () => true
        });
  
        const corsHeaders = {
          'access-control-allow-origin': response.headers['access-control-allow-origin'],
          'access-control-allow-credentials': response.headers['access-control-allow-credentials']
        };
  
        if (corsHeaders['access-control-allow-origin'] === '*' ||
            corsHeaders['access-control-allow-origin'] === origin) {
          if (corsHeaders['access-control-allow-credentials'] === 'true') {
            vulnerabilities.push({
              type: 'CORS Misconfiguration',
              severity: 'High',
              description: 'Dangerous CORS configuration detected',
              evidence: `Origin: ${origin}, Response headers: ${JSON.stringify(corsHeaders)}`,
              recommendation: 'Implement proper CORS policy, avoid wildcards, and restrict trusted origins',
              cwe: 'CWE-942',
              cvss: 6.5
            });
          }
        }
      } catch (error) {
        console.error('CORS scan error:', error);
      }
    }
  
    return vulnerabilities;
  }

  
  async function scanForSensitiveInfo(url: string): Promise<Vulnerability[]> {
    //Looks for exposed sensitive data using regex patterns like API keys, Credit cards and all that:
    const vulnerabilities: Vulnerability[] = [];
    const patterns = {
      'API Key': /(['"]?[a-zA-Z0-9_-]*api[_-]?key['"]?\s*[:=]\s*['"][a-zA-Z0-9_-]{32,}['"])/i,
      'AWS Key': /(AKIA[0-9A-Z]{16})/,
      'Email': /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/,
      'Private Key': /-----BEGIN [A-Z ]+ PRIVATE KEY-----/,
      'Social Security Number': /\b\d{3}-\d{2}-\d{4}\b/,
      'Credit Card': /\b(?:\d[ -]*?){13,16}\b/
    };
  
    try {
      const response = await axios.get(url, {
        validateStatus: () => true
      });
      const content = response.data.toString();
  
      for (const [type, pattern] of Object.entries(patterns)) {
        const matches = content.match(pattern);
        if (matches) {
          vulnerabilities.push({
            type: 'Sensitive Information Disclosure',
            severity: 'Critical',
            description: `${type} found in response`,
            evidence: `Found pattern of type: ${type}`,
            recommendation: 'Remove sensitive information from response, implement proper data masking',
            cwe: 'CWE-200',
            cvss: 7.5
          });
        }
      }
  
      // Check for common sensitive files
      const sensitiveFiles = [
        '.git/config',
        '.env',
        'phpinfo.php',
        'robots.txt',
        'crossdomain.xml',
        'sitemap.xml'
      ];
  
      for (const file of sensitiveFiles) {
        try {
          const fileResponse = await axios.get(`${url}/${file}`, {
            validateStatus: () => true,
            timeout: 3000
          });
  
          if (fileResponse.status === 200) {
            vulnerabilities.push({
              type: 'Sensitive File Exposure',
              severity: 'High',
              description: `Sensitive file ${file} is publicly accessible`,
              evidence: `File: ${file}`,
              recommendation: 'Restrict access to sensitive files, move them outside web root',
              cwe: 'CWE-538',
              cvss: 6.5
            });
          }
        } catch (error) {
          // Ignore 404 errors
          console.error('ignore 404', error);
        }
      }
    } catch (error) {
      console.error('Sensitive info scan error:', error);
    }
  
    return vulnerabilities;
  }

  

